----------------------------------------------------
-- Do not edit this file by hand.  Edit 
-- 'templates/ASCIIMathML.hs'
-- and run ./fillTemplates.pl Text/Pandoc/ASCIIMathML.hs
----------------------------------------------------

-- | Definitions for use of Pandoc.ASCIIMathML in HTML.  
-- (See <http://www1.chapman.edu/~jipsen/mathml/asciimath.html>.)
module Text.Pandoc.ASCIIMathML ( asciiMathMLScript ) where

-- | String containing Pandoc.ASCIIMathML javascript.
asciiMathMLScript :: String
asciiMathMLScript = "<script type=\"text/javascript\">\n/* ASCIIMathML.js - copyright Peter Jipsen, released under the GPL\nSee http://www1.chapman.edu/~jipsen/mathml/asciimath.html/ */\n\nvar checkForMathML = true;   // check if browser can display MathML\nvar notifyIfNoMathML = true; // display note if no MathML capability\nvar alertIfNoMathML = false;  // show alert box if no MathML capability\nvar mathcolor = \"red\";       // change it to \"\" (to inherit) or any other color\nvar mathfontfamily = \"serif\"; // change to \"\" to inherit (works in IE) \n                              // or another family (e.g. \"arial\")\nvar displaystyle = true;      // puts limits above and below large operators\nvar showasciiformulaonhover = true; // helps students learn ASCIIMath\nvar decimalsign = \".\";        // change to \",\" if you like, beware of `(1,2)`!\nvar AMdelimiter1 = \"`\", AMescape1 = \"\\\\\\\\`\"; // can use other characters\nvar AMdelimiter2 = \"$\", AMescape2 = \"\\\\\\\\\\\\$\", AMdelimiter2regexp = \"\\\\$\";\nvar doubleblankmathdelimiter = false; // if true,  x+1  is equal to `x+1`\n                                      // for IE this works only in <!--   -->\n//var separatetokens;// has been removed (email me if this is a problem)\nvar isIE = document.createElementNS==null;\n\nif (document.getElementById==null) \n  alert(\"This webpage requires a recent browser such as\\\n\\nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer\")\n\n// all further global variables start with \"AM\"\n\nfunction AMcreateElementXHTML(t) {\n  if (isIE) return document.createElement(t);\n  else return document.createElementNS(\"http://www.w3.org/1999/xhtml\",t);\n}\n\nfunction AMnoMathMLNote() {\n  var nd = AMcreateElementXHTML(\"h3\");\n  nd.setAttribute(\"align\",\"center\")\n  nd.appendChild(AMcreateElementXHTML(\"p\"));\n  nd.appendChild(document.createTextNode(\"To view the \"));\n  var an = AMcreateElementXHTML(\"a\");\n  an.appendChild(document.createTextNode(\"ASCIIMathML\"));\n  an.setAttribute(\"href\",\"http://www.chapman.edu/~jipsen/asciimath.html\");\n  nd.appendChild(an);\n  nd.appendChild(document.createTextNode(\" notation use Internet Explorer 6+\"));  \n  an = AMcreateElementXHTML(\"a\");\n  an.appendChild(document.createTextNode(\"MathPlayer\"));\n  an.setAttribute(\"href\",\"http://www.dessci.com/en/products/mathplayer/download.htm\");\n  nd.appendChild(an);\n  nd.appendChild(document.createTextNode(\" or Netscape/Mozilla/Firefox\"));\n  nd.appendChild(AMcreateElementXHTML(\"p\"));\n  return nd;\n}\n\nfunction AMisMathMLavailable() {\n  var regex = /KHTML/;   /* ASCIIMathML.js - copyright Peter Jipsen, released under the GPL\nSee http://www1.chapman.edu/~jipsen/mathml/asciimath.html/ */\n  if (navigator.appName.slice(0,8)==\"Netscape\")\n    if (navigator.appVersion.slice(0,1)>=\"5\" && !regex.test(navigator.userAgent)) return null;\n    else return AMnoMathMLNote();\n  else if (navigator.appName.slice(0,9)==\"Microsoft\")\n    try {\n        var ActiveX = new ActiveXObject(\"MathPlayer.Factory.1\");\n        return null;\n    } catch (e) {\n        return AMnoMathMLNote();\n    }\n  else return AMnoMathMLNote();\n}\n\n// character lists for Mozilla/Netscape fonts\nvar AMcal = [0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];\nvar AMfrk = [0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];\nvar AMbbb = [0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];\n\nvar CONST = 0, UNARY = 1, BINARY = 2, INFIX = 3, LEFTBRACKET = 4, \n    RIGHTBRACKET = 5, SPACE = 6, UNDEROVER = 7, DEFINITION = 8,\n    LEFTRIGHT = 9, TEXT = 10; // token types\n\nvar AMsqrt = {input:\"sqrt\", tag:\"msqrt\", output:\"sqrt\", tex:null, ttype:UNARY},\n  AMroot  = {input:\"root\", tag:\"mroot\", output:\"root\", tex:null, ttype:BINARY},\n  AMfrac  = {input:\"frac\", tag:\"mfrac\", output:\"/\",    tex:null, ttype:BINARY},\n  AMdiv   = {input:\"/\",    tag:\"mfrac\", output:\"/\",    tex:null, ttype:INFIX},\n  AMover  = {input:\"stackrel\", tag:\"mover\", output:\"stackrel\", tex:null, ttype:BINARY},\n  AMsub   = {input:\"_\",    tag:\"msub\",  output:\"_\",    tex:null, ttype:INFIX},\n  AMsup   = {input:\"^\",    tag:\"msup\",  output:\"^\",    tex:null, ttype:INFIX},\n  AMtext  = {input:\"text\", tag:\"mtext\", output:\"text\", tex:null, ttype:TEXT},\n  AMmbox  = {input:\"mbox\", tag:\"mtext\", output:\"mbox\", tex:null, ttype:TEXT},\n  AMquote = {input:\"\\\"\",   tag:\"mtext\", output:\"mbox\", tex:null, ttype:TEXT};\n\nvar AMsymbols = [\n//some greek symbols\n{input:\"alpha\",  tag:\"mi\", output:\"\\u03B1\", tex:null, ttype:CONST},\n{input:\"beta\",   tag:\"mi\", output:\"\\u03B2\", tex:null, ttype:CONST},\n{input:\"chi\",    tag:\"mi\", output:\"\\u03C7\", tex:null, ttype:CONST},\n{input:\"delta\",  tag:\"mi\", output:\"\\u03B4\", tex:null, ttype:CONST},\n{input:\"Delta\",  tag:\"mo\", output:\"\\u0394\", tex:null, ttype:CONST},\n{input:\"epsi\",   tag:\"mi\", output:\"\\u03B5\", tex:\"epsilon\", ttype:CONST},\n{input:\"varepsilon\", tag:\"mi\", output:\"\\u025B\", tex:null, ttype:CONST},\n{input:\"eta\",    tag:\"mi\", output:\"\\u03B7\", tex:null, ttype:CONST},\n{input:\"gamma\",  tag:\"mi\", output:\"\\u03B3\", tex:null, ttype:CONST},\n{input:\"Gamma\",  tag:\"mo\", output:\"\\u0393\", tex:null, ttype:CONST},\n{input:\"iota\",   tag:\"mi\", output:\"\\u03B9\", tex:null, ttype:CONST},\n{input:\"kappa\",  tag:\"mi\", output:\"\\u03BA\", tex:null, ttype:CONST},\n{input:\"lambda\", tag:\"mi\", output:\"\\u03BB\", tex:null, ttype:CONST},\n{input:\"Lambda\", tag:\"mo\", output:\"\\u039B\", tex:null, ttype:CONST},\n{input:\"mu\",     tag:\"mi\", output:\"\\u03BC\", tex:null, ttype:CONST},\n{input:\"nu\",     tag:\"mi\", output:\"\\u03BD\", tex:null, ttype:CONST},\n{input:\"omega\",  tag:\"mi\", output:\"\\u03C9\", tex:null, ttype:CONST},\n{input:\"Omega\",  tag:\"mo\", output:\"\\u03A9\", tex:null, ttype:CONST},\n{input:\"phi\",    tag:\"mi\", output:\"\\u03C6\", tex:null, ttype:CONST},\n{input:\"varphi\", tag:\"mi\", output:\"\\u03D5\", tex:null, ttype:CONST},\n{input:\"Phi\",    tag:\"mo\", output:\"\\u03A6\", tex:null, ttype:CONST},\n{input:\"pi\",     tag:\"mi\", output:\"\\u03C0\", tex:null, ttype:CONST},\n{input:\"Pi\",     tag:\"mo\", output:\"\\u03A0\", tex:null, ttype:CONST},\n{input:\"psi\",    tag:\"mi\", output:\"\\u03C8\", tex:null, ttype:CONST},\n{input:\"Psi\",    tag:\"mi\", output:\"\\u03A8\", tex:null, ttype:CONST},\n{input:\"rho\",    tag:\"mi\", output:\"\\u03C1\", tex:null, ttype:CONST},\n{input:\"sigma\",  tag:\"mi\", output:\"\\u03C3\", tex:null, ttype:CONST},\n{input:\"Sigma\",  tag:\"mo\", output:\"\\u03A3\", tex:null, ttype:CONST},\n{input:\"tau\",    tag:\"mi\", output:\"\\u03C4\", tex:null, ttype:CONST},\n{input:\"theta\",  tag:\"mi\", output:\"\\u03B8\", tex:null, ttype:CONST},\n{input:\"vartheta\", tag:\"mi\", output:\"\\u03D1\", tex:null, ttype:CONST},\n{input:\"Theta\",  tag:\"mo\", output:\"\\u0398\", tex:null, ttype:CONST},\n{input:\"upsilon\", tag:\"mi\", output:\"\\u03C5\", tex:null, ttype:CONST},\n{input:\"xi\",     tag:\"mi\", output:\"\\u03BE\", tex:null, ttype:CONST},\n{input:\"Xi\",     tag:\"mo\", output:\"\\u039E\", tex:null, ttype:CONST},\n{input:\"zeta\",   tag:\"mi\", output:\"\\u03B6\", tex:null, ttype:CONST},\n\n//binary operation symbols\n{input:\"*\",  tag:\"mo\", output:\"\\u22C5\", tex:\"cdot\", ttype:CONST},\n{input:\"**\", tag:\"mo\", output:\"\\u22C6\", tex:\"star\", ttype:CONST},\n{input:\"//\", tag:\"mo\", output:\"/\",      tex:null, ttype:CONST},\n{input:\"\\\\\\\\\", tag:\"mo\", output:\"\\\\\",   tex:\"backslash\", ttype:CONST},\n{input:\"setminus\", tag:\"mo\", output:\"\\\\\", tex:null, ttype:CONST},\n{input:\"xx\", tag:\"mo\", output:\"\\u00D7\", tex:\"times\", ttype:CONST},\n{input:\"-:\", tag:\"mo\", output:\"\\u00F7\", tex:\"divide\", ttype:CONST},\n{input:\"@\",  tag:\"mo\", output:\"\\u2218\", tex:\"circ\", ttype:CONST},\n{input:\"o+\", tag:\"mo\", output:\"\\u2295\", tex:\"oplus\", ttype:CONST},\n{input:\"ox\", tag:\"mo\", output:\"\\u2297\", tex:\"otimes\", ttype:CONST},\n{input:\"o.\", tag:\"mo\", output:\"\\u2299\", tex:\"odot\", ttype:CONST},\n{input:\"sum\", tag:\"mo\", output:\"\\u2211\", tex:null, ttype:UNDEROVER},\n{input:\"prod\", tag:\"mo\", output:\"\\u220F\", tex:null, ttype:UNDEROVER},\n{input:\"^^\",  tag:\"mo\", output:\"\\u2227\", tex:\"wedge\", ttype:CONST},\n{input:\"^^^\", tag:\"mo\", output:\"\\u22C0\", tex:\"bigwedge\", ttype:UNDEROVER},\n{input:\"vv\",  tag:\"mo\", output:\"\\u2228\", tex:\"vee\", ttype:CONST},\n{input:\"vvv\", tag:\"mo\", output:\"\\u22C1\", tex:\"bigvee\", ttype:UNDEROVER},\n{input:\"nn\",  tag:\"mo\", output:\"\\u2229\", tex:\"cap\", ttype:CONST},\n{input:\"nnn\", tag:\"mo\", output:\"\\u22C2\", tex:\"bigcap\", ttype:UNDEROVER},\n{input:\"uu\",  tag:\"mo\", output:\"\\u222A\", tex:\"cup\", ttype:CONST},\n{input:\"uuu\", tag:\"mo\", output:\"\\u22C3\", tex:\"bigcup\", ttype:UNDEROVER},\n\n//binary relation symbols\n{input:\"!=\",  tag:\"mo\", output:\"\\u2260\", tex:\"ne\", ttype:CONST},\n{input:\":=\",  tag:\"mo\", output:\":=\",     tex:null, ttype:CONST},\n{input:\"lt\",  tag:\"mo\", output:\"<\",      tex:null, ttype:CONST},\n{input:\"<=\",  tag:\"mo\", output:\"\\u2264\", tex:\"le\", ttype:CONST},\n{input:\"lt=\", tag:\"mo\", output:\"\\u2264\", tex:\"leq\", ttype:CONST},\n{input:\">=\",  tag:\"mo\", output:\"\\u2265\", tex:\"ge\", ttype:CONST},\n{input:\"geq\", tag:\"mo\", output:\"\\u2265\", tex:null, ttype:CONST},\n{input:\"-<\",  tag:\"mo\", output:\"\\u227A\", tex:\"prec\", ttype:CONST},\n{input:\"-lt\", tag:\"mo\", output:\"\\u227A\", tex:null, ttype:CONST},\n{input:\">-\",  tag:\"mo\", output:\"\\u227B\", tex:\"succ\", ttype:CONST},\n{input:\"-<=\", tag:\"mo\", output:\"\\u2AAF\", tex:\"preceq\", ttype:CONST},\n{input:\">-=\", tag:\"mo\", output:\"\\u2AB0\", tex:\"succeq\", ttype:CONST},\n{input:\"in\",  tag:\"mo\", output:\"\\u2208\", tex:null, ttype:CONST},\n{input:\"!in\", tag:\"mo\", output:\"\\u2209\", tex:\"notin\", ttype:CONST},\n{input:\"sub\", tag:\"mo\", output:\"\\u2282\", tex:\"subset\", ttype:CONST},\n{input:\"sup\", tag:\"mo\", output:\"\\u2283\", tex:\"supset\", ttype:CONST},\n{input:\"sube\", tag:\"mo\", output:\"\\u2286\", tex:\"subseteq\", ttype:CONST},\n{input:\"supe\", tag:\"mo\", output:\"\\u2287\", tex:\"supseteq\", ttype:CONST},\n{input:\"-=\",  tag:\"mo\", output:\"\\u2261\", tex:\"equiv\", ttype:CONST},\n{input:\"~=\",  tag:\"mo\", output:\"\\u2245\", tex:\"cong\", ttype:CONST},\n{input:\"~~\",  tag:\"mo\", output:\"\\u2248\", tex:\"approx\", ttype:CONST},\n{input:\"prop\", tag:\"mo\", output:\"\\u221D\", tex:\"propto\", ttype:CONST},\n\n//logical symbols\n{input:\"and\", tag:\"mtext\", output:\"and\", tex:null, ttype:SPACE},\n{input:\"or\",  tag:\"mtext\", output:\"or\",  tex:null, ttype:SPACE},\n{input:\"not\", tag:\"mo\", output:\"\\u00AC\", tex:\"neg\", ttype:CONST},\n{input:\"=>\",  tag:\"mo\", output:\"\\u21D2\", tex:\"implies\", ttype:CONST},\n{input:\"if\",  tag:\"mo\", output:\"if\",     tex:null, ttype:SPACE},\n{input:\"<=>\", tag:\"mo\", output:\"\\u21D4\", tex:\"iff\", ttype:CONST},\n{input:\"AA\",  tag:\"mo\", output:\"\\u2200\", tex:\"forall\", ttype:CONST},\n{input:\"EE\",  tag:\"mo\", output:\"\\u2203\", tex:\"exists\", ttype:CONST},\n{input:\"_|_\", tag:\"mo\", output:\"\\u22A5\", tex:\"bot\", ttype:CONST},\n{input:\"TT\",  tag:\"mo\", output:\"\\u22A4\", tex:\"top\", ttype:CONST},\n{input:\"|--\",  tag:\"mo\", output:\"\\u22A2\", tex:\"vdash\", ttype:CONST},\n{input:\"|==\",  tag:\"mo\", output:\"\\u22A8\", tex:\"models\", ttype:CONST},\n\n//grouping brackets\n{input:\"(\", tag:\"mo\", output:\"(\", tex:null, ttype:LEFTBRACKET},\n{input:\")\", tag:\"mo\", output:\")\", tex:null, ttype:RIGHTBRACKET},\n{input:\"[\", tag:\"mo\", output:\"[\", tex:null, ttype:LEFTBRACKET},\n{input:\"]\", tag:\"mo\", output:\"]\", tex:null, ttype:RIGHTBRACKET},\n{input:\"{\", tag:\"mo\", output:\"{\", tex:null, ttype:LEFTBRACKET},\n{input:\"}\", tag:\"mo\", output:\"}\", tex:null, ttype:RIGHTBRACKET},\n{input:\"|\", tag:\"mo\", output:\"|\", tex:null, ttype:LEFTRIGHT},\n//{input:\"||\", tag:\"mo\", output:\"||\", tex:null, ttype:LEFTRIGHT},\n{input:\"(:\", tag:\"mo\", output:\"\\u2329\", tex:\"langle\", ttype:LEFTBRACKET},\n{input:\":)\", tag:\"mo\", output:\"\\u232A\", tex:\"rangle\", ttype:RIGHTBRACKET},\n{input:\"<<\", tag:\"mo\", output:\"\\u2329\", tex:null, ttype:LEFTBRACKET},\n{input:\">>\", tag:\"mo\", output:\"\\u232A\", tex:null, ttype:RIGHTBRACKET},\n{input:\"{:\", tag:\"mo\", output:\"{:\", tex:null, ttype:LEFTBRACKET, invisible:true},\n{input:\":}\", tag:\"mo\", output:\":}\", tex:null, ttype:RIGHTBRACKET, invisible:true},\n\n//miscellaneous symbols\n{input:\"int\",  tag:\"mo\", output:\"\\u222B\", tex:null, ttype:CONST},\n{input:\"dx\",   tag:\"mi\", output:\"{:d x:}\", tex:null, ttype:DEFINITION},\n{input:\"dy\",   tag:\"mi\", output:\"{:d y:}\", tex:null, ttype:DEFINITION},\n{input:\"dz\",   tag:\"mi\", output:\"{:d z:}\", tex:null, ttype:DEFINITION},\n{input:\"dt\",   tag:\"mi\", output:\"{:d t:}\", tex:null, ttype:DEFINITION},\n{input:\"oint\", tag:\"mo\", output:\"\\u222E\", tex:null, ttype:CONST},\n{input:\"del\",  tag:\"mo\", output:\"\\u2202\", tex:\"partial\", ttype:CONST},\n{input:\"grad\", tag:\"mo\", output:\"\\u2207\", tex:\"nabla\", ttype:CONST},\n{input:\"+-\",   tag:\"mo\", output:\"\\u00B1\", tex:\"pm\", ttype:CONST},\n{input:\"O/\",   tag:\"mo\", output:\"\\u2205\", tex:\"emptyset\", ttype:CONST},\n{input:\"oo\",   tag:\"mo\", output:\"\\u221E\", tex:\"infty\", ttype:CONST},\n{input:\"aleph\", tag:\"mo\", output:\"\\u2135\", tex:null, ttype:CONST},\n{input:\"...\",  tag:\"mo\", output:\"...\",    tex:\"ldots\", ttype:CONST},\n{input:\":.\",  tag:\"mo\", output:\"\\u2234\",  tex:\"therefore\", ttype:CONST},\n{input:\"/_\",  tag:\"mo\", output:\"\\u2220\",  tex:\"angle\", ttype:CONST},\n{input:\"\\\\ \",  tag:\"mo\", output:\"\\u00A0\", tex:null, ttype:CONST},\n{input:\"quad\", tag:\"mo\", output:\"\\u00A0\\u00A0\", tex:null, ttype:CONST},\n{input:\"qquad\", tag:\"mo\", output:\"\\u00A0\\u00A0\\u00A0\\u00A0\", tex:null, ttype:CONST},\n{input:\"cdots\", tag:\"mo\", output:\"\\u22EF\", tex:null, ttype:CONST},\n{input:\"vdots\", tag:\"mo\", output:\"\\u22EE\", tex:null, ttype:CONST},\n{input:\"ddots\", tag:\"mo\", output:\"\\u22F1\", tex:null, ttype:CONST},\n{input:\"diamond\", tag:\"mo\", output:\"\\u22C4\", tex:null, ttype:CONST},\n{input:\"square\", tag:\"mo\", output:\"\\u25A1\", tex:null, ttype:CONST},\n{input:\"|__\", tag:\"mo\", output:\"\\u230A\",  tex:\"lfloor\", ttype:CONST},\n{input:\"__|\", tag:\"mo\", output:\"\\u230B\",  tex:\"rfloor\", ttype:CONST},\n{input:\"|~\", tag:\"mo\", output:\"\\u2308\",  tex:\"lceiling\", ttype:CONST},\n{input:\"~|\", tag:\"mo\", output:\"\\u2309\",  tex:\"rceiling\", ttype:CONST},\n{input:\"CC\",  tag:\"mo\", output:\"\\u2102\", tex:null, ttype:CONST},\n{input:\"NN\",  tag:\"mo\", output:\"\\u2115\", tex:null, ttype:CONST},\n{input:\"QQ\",  tag:\"mo\", output:\"\\u211A\", tex:null, ttype:CONST},\n{input:\"RR\",  tag:\"mo\", output:\"\\u211D\", tex:null, ttype:CONST},\n{input:\"ZZ\",  tag:\"mo\", output:\"\\u2124\", tex:null, ttype:CONST},\n{input:\"f\",   tag:\"mi\", output:\"f\",      tex:null, ttype:UNARY, func:true},\n{input:\"g\",   tag:\"mi\", output:\"g\",      tex:null, ttype:UNARY, func:true},\n\n//standard functions\n{input:\"lim\",  tag:\"mo\", output:\"lim\", tex:null, ttype:UNDEROVER},\n{input:\"Lim\",  tag:\"mo\", output:\"Lim\", tex:null, ttype:UNDEROVER},\n{input:\"sin\",  tag:\"mo\", output:\"sin\", tex:null, ttype:UNARY, func:true},\n{input:\"cos\",  tag:\"mo\", output:\"cos\", tex:null, ttype:UNARY, func:true},\n{input:\"tan\",  tag:\"mo\", output:\"tan\", tex:null, ttype:UNARY, func:true},\n{input:\"sinh\", tag:\"mo\", output:\"sinh\", tex:null, ttype:UNARY, func:true},\n{input:\"cosh\", tag:\"mo\", output:\"cosh\", tex:null, ttype:UNARY, func:true},\n{input:\"tanh\", tag:\"mo\", output:\"tanh\", tex:null, ttype:UNARY, func:true},\n{input:\"cot\",  tag:\"mo\", output:\"cot\", tex:null, ttype:UNARY, func:true},\n{input:\"sec\",  tag:\"mo\", output:\"sec\", tex:null, ttype:UNARY, func:true},\n{input:\"csc\",  tag:\"mo\", output:\"csc\", tex:null, ttype:UNARY, func:true},\n{input:\"log\",  tag:\"mo\", output:\"log\", tex:null, ttype:UNARY, func:true},\n{input:\"ln\",   tag:\"mo\", output:\"ln\",  tex:null, ttype:UNARY, func:true},\n{input:\"det\",  tag:\"mo\", output:\"det\", tex:null, ttype:UNARY, func:true},\n{input:\"dim\",  tag:\"mo\", output:\"dim\", tex:null, ttype:CONST},\n{input:\"mod\",  tag:\"mo\", output:\"mod\", tex:null, ttype:CONST},\n{input:\"gcd\",  tag:\"mo\", output:\"gcd\", tex:null, ttype:UNARY, func:true},\n{input:\"lcm\",  tag:\"mo\", output:\"lcm\", tex:null, ttype:UNARY, func:true},\n{input:\"lub\",  tag:\"mo\", output:\"lub\", tex:null, ttype:CONST},\n{input:\"glb\",  tag:\"mo\", output:\"glb\", tex:null, ttype:CONST},\n{input:\"min\",  tag:\"mo\", output:\"min\", tex:null, ttype:UNDEROVER},\n{input:\"max\",  tag:\"mo\", output:\"max\", tex:null, ttype:UNDEROVER},\n\n//arrows\n{input:\"uarr\", tag:\"mo\", output:\"\\u2191\", tex:\"uparrow\", ttype:CONST},\n{input:\"darr\", tag:\"mo\", output:\"\\u2193\", tex:\"downarrow\", ttype:CONST},\n{input:\"rarr\", tag:\"mo\", output:\"\\u2192\", tex:\"rightarrow\", ttype:CONST},\n{input:\"->\",   tag:\"mo\", output:\"\\u2192\", tex:\"to\", ttype:CONST},\n{input:\"|->\",  tag:\"mo\", output:\"\\u21A6\", tex:\"mapsto\", ttype:CONST},\n{input:\"larr\", tag:\"mo\", output:\"\\u2190\", tex:\"leftarrow\", ttype:CONST},\n{input:\"harr\", tag:\"mo\", output:\"\\u2194\", tex:\"leftrightarrow\", ttype:CONST},\n{input:\"rArr\", tag:\"mo\", output:\"\\u21D2\", tex:\"Rightarrow\", ttype:CONST},\n{input:\"lArr\", tag:\"mo\", output:\"\\u21D0\", tex:\"Leftarrow\", ttype:CONST},\n{input:\"hArr\", tag:\"mo\", output:\"\\u21D4\", tex:\"Leftrightarrow\", ttype:CONST},\n\n//commands with argument\nAMsqrt, AMroot, AMfrac, AMdiv, AMover, AMsub, AMsup,\n{input:\"hat\", tag:\"mover\", output:\"\\u005E\", tex:null, ttype:UNARY, acc:true},\n{input:\"bar\", tag:\"mover\", output:\"\\u00AF\", tex:\"overline\", ttype:UNARY, acc:true},\n{input:\"vec\", tag:\"mover\", output:\"\\u2192\", tex:null, ttype:UNARY, acc:true},\n{input:\"dot\", tag:\"mover\", output:\".\",      tex:null, ttype:UNARY, acc:true},\n{input:\"ddot\", tag:\"mover\", output:\"..\",    tex:null, ttype:UNARY, acc:true},\n{input:\"ul\", tag:\"munder\", output:\"\\u0332\", tex:\"underline\", ttype:UNARY, acc:true},\nAMtext, AMmbox, AMquote,\n{input:\"bb\", tag:\"mstyle\", atname:\"fontweight\", atval:\"bold\", output:\"bb\", tex:null, ttype:UNARY},\n{input:\"mathbf\", tag:\"mstyle\", atname:\"fontweight\", atval:\"bold\", output:\"mathbf\", tex:null, ttype:UNARY},\n{input:\"sf\", tag:\"mstyle\", atname:\"fontfamily\", atval:\"sans-serif\", output:\"sf\", tex:null, ttype:UNARY},\n{input:\"mathsf\", tag:\"mstyle\", atname:\"fontfamily\", atval:\"sans-serif\", output:\"mathsf\", tex:null, ttype:UNARY},\n{input:\"bbb\", tag:\"mstyle\", atname:\"mathvariant\", atval:\"double-struck\", output:\"bbb\", tex:null, ttype:UNARY, codes:AMbbb},\n{input:\"mathbb\", tag:\"mstyle\", atname:\"mathvariant\", atval:\"double-struck\", output:\"mathbb\", tex:null, ttype:UNARY, codes:AMbbb},\n{input:\"cc\",  tag:\"mstyle\", atname:\"mathvariant\", atval:\"script\", output:\"cc\", tex:null, ttype:UNARY, codes:AMcal},\n{input:\"mathcal\", tag:\"mstyle\", atname:\"mathvariant\", atval:\"script\", output:\"mathcal\", tex:null, ttype:UNARY, codes:AMcal},\n{input:\"tt\",  tag:\"mstyle\", atname:\"fontfamily\", atval:\"monospace\", output:\"tt\", tex:null, ttype:UNARY},\n{input:\"mathtt\", tag:\"mstyle\", atname:\"fontfamily\", atval:\"monospace\", output:\"mathtt\", tex:null, ttype:UNARY},\n{input:\"fr\",  tag:\"mstyle\", atname:\"mathvariant\", atval:\"fraktur\", output:\"fr\", tex:null, ttype:UNARY, codes:AMfrk},\n{input:\"mathfrak\",  tag:\"mstyle\", atname:\"mathvariant\", atval:\"fraktur\", output:\"mathfrak\", tex:null, ttype:UNARY, codes:AMfrk}\n];\n\nfunction compareNames(s1,s2) {\n  if (s1.input > s2.input) return 1\n  else return -1;\n}\n\nvar AMnames = []; //list of input symbols\n\nfunction AMinitSymbols() {\n  var texsymbols = [], i;\n  for (i=0; i<AMsymbols.length; i++)\n    if (AMsymbols[i].tex) \n      texsymbols[texsymbols.length] = {input:AMsymbols[i].tex, \n        tag:AMsymbols[i].tag, output:AMsymbols[i].output, ttype:AMsymbols[i].ttype};\n  AMsymbols = AMsymbols.concat(texsymbols);\n  AMsymbols.sort(compareNames);\n  for (i=0; i<AMsymbols.length; i++) AMnames[i] = AMsymbols[i].input;\n}\n\nvar AMmathml = \"http://www.w3.org/1998/Math/MathML\";\n\nfunction AMcreateElementMathML(t) {\n  if (isIE) return document.createElement(\"m:\"+t);\n  else return document.createElementNS(AMmathml,t);\n}\n\nfunction AMcreateMmlNode(t,frag) {\n//  var node = AMcreateElementMathML(name);\n  if (isIE) var node = document.createElement(\"m:\"+t);\n  else var node = document.createElementNS(AMmathml,t);\n  node.appendChild(frag);\n  return node;\n}\n\nfunction newcommand(oldstr,newstr) {\n  AMsymbols = AMsymbols.concat([{input:oldstr, tag:\"mo\", output:newstr, \n                                 tex:null, ttype:DEFINITION}]);\n}\n\nfunction AMremoveCharsAndBlanks(str,n) {\n//remove n characters and any following blanks\n  var st;\n  if (str.charAt(n)==\"\\\\\" && str.charAt(n+1)!=\"\\\\\" && str.charAt(n+1)!=\" \") \n    st = str.slice(n+1);\n  else st = str.slice(n);\n  for (var i=0; i<st.length && st.charCodeAt(i)<=32; i=i+1);\n  return st.slice(i);\n}\n\nfunction AMposition(arr, str, n) { \n// return position >=n where str appears or would be inserted\n// assumes arr is sorted\n  if (n==0) {\n    var h,m;\n    n = -1;\n    h = arr.length;\n    while (n+1<h) {\n      m = (n+h) >> 1;\n      if (arr[m]<str) n = m; else h = m;\n    }\n    return h;\n  } else\n    for (var i=n; i<arr.length && arr[i]<str; i++);\n  return i; // i=arr.length || arr[i]>=str\n}\n\nfunction AMgetSymbol(str) {\n//return maximal initial substring of str that appears in names\n//return null if there is none\n  var k = 0; //new pos\n  var j = 0; //old pos\n  var mk; //match pos\n  var st;\n  var tagst;\n  var match = \"\";\n  var more = true;\n  for (var i=1; i<=str.length && more; i++) {\n    st = str.slice(0,i); //initial substring of length i\n    j = k;\n    k = AMposition(AMnames, st, j);\n    if (k<AMnames.length && str.slice(0,AMnames[k].length)==AMnames[k]){\n      match = AMnames[k];\n      mk = k;\n      i = match.length;\n    }\n    more = k<AMnames.length && str.slice(0,AMnames[k].length)>=AMnames[k];\n  }\n  AMpreviousSymbol=AMcurrentSymbol;\n  if (match!=\"\"){\n    AMcurrentSymbol=AMsymbols[mk].ttype;\n    return AMsymbols[mk]; \n  }\n// if str[0] is a digit or - return maxsubstring of digits.digits\n  AMcurrentSymbol=CONST;\n  k = 1;\n  st = str.slice(0,1);\n  var integ = true;\n  while (\"0\"<=st && st<=\"9\" && k<=str.length) {\n    st = str.slice(k,k+1);\n    k++;\n  }\n  if (st == decimalsign) {\n    st = str.slice(k,k+1);\n    if (\"0\"<=st && st<=\"9\") {\n      integ = false;\n      k++;\n      while (\"0\"<=st && st<=\"9\" && k<=str.length) {\n        st = str.slice(k,k+1);\n        k++;\n      }\n    }\n  }\n  if ((integ && k>1) || k>2) {\n    st = str.slice(0,k-1);\n    tagst = \"mn\";\n  } else {\n    k = 2;\n    st = str.slice(0,1); //take 1 character\n    tagst = ((\"A\">st || st>\"Z\") && (\"a\">st || st>\"z\")?\"mo\":\"mi\");\n  }\n  if (st==\"-\" && AMpreviousSymbol==INFIX) {\n    AMcurrentSymbol = INFIX;  //trick \"/\" into recognizing \"-\" on second parse\n    return {input:st, tag:tagst, output:st, ttype:UNARY, func:true};\n  }\n  return {input:st, tag:tagst, output:st, ttype:CONST};\n}\n\nfunction AMremoveBrackets(node) {\n  var st;\n  if (node.nodeName==\"mrow\") {\n    st = node.firstChild.firstChild.nodeValue;\n    if (st==\"(\" || st==\"[\" || st==\"{\") node.removeChild(node.firstChild);\n  }\n  if (node.nodeName==\"mrow\") {\n    st = node.lastChild.firstChild.nodeValue;\n    if (st==\")\" || st==\"]\" || st==\"}\") node.removeChild(node.lastChild);\n  }\n}\n\n/* ASCIIMathML.js - copyright Peter Jipsen, released under the GPL\nSee http://www1.chapman.edu/~jipsen/mathml/asciimath.html/ */\n\nvar AMnestingDepth,AMpreviousSymbol,AMcurrentSymbol;\n\nfunction AMparseSexpr(str) { //parses str and returns [node,tailstr]\n  var symbol, node, result, i, st,// rightvert = false,\n    newFrag = document.createDocumentFragment();\n  str = AMremoveCharsAndBlanks(str,0);\n  symbol = AMgetSymbol(str);             //either a token or a bracket or empty\n  if (symbol == null || symbol.ttype == RIGHTBRACKET && AMnestingDepth > 0) {\n    return [null,str];\n  }\n  if (symbol.ttype == DEFINITION) {\n    str = symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length); \n    symbol = AMgetSymbol(str);\n  }\n  switch (symbol.ttype) {\n  case UNDEROVER:\n  case CONST:\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    return [AMcreateMmlNode(symbol.tag,        //its a constant\n                             document.createTextNode(symbol.output)),str];\n  case LEFTBRACKET:   //read (expr+)\n    AMnestingDepth++;\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    result = AMparseExpr(str,true);\n    AMnestingDepth--;\n    if (typeof symbol.invisible == \"boolean\" && symbol.invisible) \n      node = AMcreateMmlNode(\"mrow\",result[0]);\n    else {\n      node = AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output));\n      node = AMcreateMmlNode(\"mrow\",node);\n      node.appendChild(result[0]);\n    }\n    return [node,result[1]];\n  case TEXT:\n      if (symbol!=AMquote) str = AMremoveCharsAndBlanks(str,symbol.input.length);\n      if (str.charAt(0)==\"{\") i=str.indexOf(\"}\");\n      else if (str.charAt(0)==\"(\") i=str.indexOf(\")\");\n      else if (str.charAt(0)==\"[\") i=str.indexOf(\"]\");\n      else if (symbol==AMquote) i=str.slice(1).indexOf(\"\\\"\")+1;\n      else i = 0;\n      if (i==-1) i = str.length;\n      st = str.slice(1,i);\n      if (st.charAt(0) == \" \") {\n        node = AMcreateElementMathML(\"mspace\");\n        node.setAttribute(\"width\",\"1ex\");\n        newFrag.appendChild(node);\n      }\n      newFrag.appendChild(\n        AMcreateMmlNode(symbol.tag,document.createTextNode(st)));\n      if (st.charAt(st.length-1) == \" \") {\n        node = AMcreateElementMathML(\"mspace\");\n        node.setAttribute(\"width\",\"1ex\");\n        newFrag.appendChild(node);\n      }\n      str = AMremoveCharsAndBlanks(str,i+1);\n      return [AMcreateMmlNode(\"mrow\",newFrag),str];\n  case UNARY:\n      str = AMremoveCharsAndBlanks(str,symbol.input.length); \n      result = AMparseSexpr(str);\n      if (result[0]==null) return [AMcreateMmlNode(symbol.tag,\n                             document.createTextNode(symbol.output)),str];\n      if (typeof symbol.func == \"boolean\" && symbol.func) { // functions hack\n        st = str.charAt(0);\n        if (st==\"^\" || st==\"_\" || st==\"/\" || st==\"|\" || st==\",\") {\n          return [AMcreateMmlNode(symbol.tag,\n                    document.createTextNode(symbol.output)),str];\n        } else {\n          node = AMcreateMmlNode(\"mrow\",\n           AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));\n          node.appendChild(result[0]);\n          return [node,result[1]];\n        }\n      }\n      AMremoveBrackets(result[0]);\n      if (symbol.input == \"sqrt\") {           // sqrt\n        return [AMcreateMmlNode(symbol.tag,result[0]),result[1]];\n      } else if (typeof symbol.acc == \"boolean\" && symbol.acc) {   // accent\n        node = AMcreateMmlNode(symbol.tag,result[0]);\n        node.appendChild(AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output)));\n        return [node,result[1]];\n      } else {                        // font change command\n        if (!isIE && typeof symbol.codes != \"undefined\") {\n          for (i=0; i<result[0].childNodes.length; i++)\n            if (result[0].childNodes[i].nodeName==\"mi\" || result[0].nodeName==\"mi\") {\n              st = (result[0].nodeName==\"mi\"?result[0].firstChild.nodeValue:\n                              result[0].childNodes[i].firstChild.nodeValue);\n              var newst = [];\n              for (var j=0; j<st.length; j++)\n                if (st.charCodeAt(j)>64 && st.charCodeAt(j)<91) newst = newst +\n                  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);\n                else newst = newst + st.charAt(j);\n              if (result[0].nodeName==\"mi\")\n                result[0]=AMcreateElementMathML(\"mo\").\n                          appendChild(document.createTextNode(newst));\n              else result[0].replaceChild(AMcreateElementMathML(\"mo\").\n          appendChild(document.createTextNode(newst)),result[0].childNodes[i]);\n            }\n        }\n        node = AMcreateMmlNode(symbol.tag,result[0]);\n        node.setAttribute(symbol.atname,symbol.atval);\n        return [node,result[1]];\n      }\n  case BINARY:\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    result = AMparseSexpr(str);\n    if (result[0]==null) return [AMcreateMmlNode(\"mo\",\n                           document.createTextNode(symbol.input)),str];\n    AMremoveBrackets(result[0]);\n    var result2 = AMparseSexpr(result[1]);\n    if (result2[0]==null) return [AMcreateMmlNode(\"mo\",\n                           document.createTextNode(symbol.input)),str];\n    AMremoveBrackets(result2[0]);\n    if (symbol.input==\"root\" || symbol.input==\"stackrel\") \n      newFrag.appendChild(result2[0]);\n    newFrag.appendChild(result[0]);\n    if (symbol.input==\"frac\") newFrag.appendChild(result2[0]);\n    return [AMcreateMmlNode(symbol.tag,newFrag),result2[1]];\n  case INFIX:\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    return [AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output)),str];\n  case SPACE:\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    node = AMcreateElementMathML(\"mspace\");\n    node.setAttribute(\"width\",\"1ex\");\n    newFrag.appendChild(node);\n    newFrag.appendChild(\n      AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));\n    node = AMcreateElementMathML(\"mspace\");\n    node.setAttribute(\"width\",\"1ex\");\n    newFrag.appendChild(node);\n    return [AMcreateMmlNode(\"mrow\",newFrag),str];\n  case LEFTRIGHT:\n//    if (rightvert) return [null,str]; else rightvert = true;\n    AMnestingDepth++;\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    result = AMparseExpr(str,false);\n    AMnestingDepth--;\n    var st = \"\";\n    if (result[0].lastChild!=null)\n      st = result[0].lastChild.firstChild.nodeValue;\n    if (st == \"|\") { // its an absolute value subterm\n      node = AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output));\n      node = AMcreateMmlNode(\"mrow\",node);\n      node.appendChild(result[0]);\n      return [node,result[1]];\n    } else { // the \"|\" is a \\mid\n      node = AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output));\n      node = AMcreateMmlNode(\"mrow\",node);\n      return [node,str];\n    }\n  default:\n//alert(\"default\");\n    str = AMremoveCharsAndBlanks(str,symbol.input.length); \n    return [AMcreateMmlNode(symbol.tag,        //its a constant\n                             document.createTextNode(symbol.output)),str];\n  }\n}\n\nfunction AMparseIexpr(str) {\n  var symbol, sym1, sym2, node, result, underover;\n  str = AMremoveCharsAndBlanks(str,0);\n  sym1 = AMgetSymbol(str);\n  result = AMparseSexpr(str);\n  node = result[0];\n  str = result[1];\n  symbol = AMgetSymbol(str);\n  if (symbol.ttype == INFIX && symbol.input != \"/\") {\n    str = AMremoveCharsAndBlanks(str,symbol.input.length);\n//    if (symbol.input == \"/\") result = AMparseIexpr(str); else ...\n    result = AMparseSexpr(str);\n    if (result[0] == null) // show box in place of missing argument\n      result[0] = AMcreateMmlNode(\"mo\",document.createTextNode(\"\\u25A1\"));\n    else AMremoveBrackets(result[0]);\n    str = result[1];\n//    if (symbol.input == \"/\") AMremoveBrackets(node);\n    if (symbol.input == \"_\") {\n      sym2 = AMgetSymbol(str);\n      underover = (sym1.ttype == UNDEROVER);\n      if (sym2.input == \"^\") {\n        str = AMremoveCharsAndBlanks(str,sym2.input.length);\n        var res2 = AMparseSexpr(str);\n        AMremoveBrackets(res2[0]);\n        str = res2[1];\n        node = AMcreateMmlNode((underover?\"munderover\":\"msubsup\"),node);\n        node.appendChild(result[0]);\n        node.appendChild(res2[0]);\n        node = AMcreateMmlNode(\"mrow\",node); // so sum does not stretch\n      } else {\n        node = AMcreateMmlNode((underover?\"munder\":\"msub\"),node);\n        node.appendChild(result[0]);\n      }\n    } else {\n      node = AMcreateMmlNode(symbol.tag,node);\n      node.appendChild(result[0]);\n    }\n  }\n  return [node,str];\n}\n\nfunction AMparseExpr(str,rightbracket) {\n  var symbol, node, result, i, nodeList = [],\n  newFrag = document.createDocumentFragment();\n  do {\n    str = AMremoveCharsAndBlanks(str,0);\n    result = AMparseIexpr(str);\n    node = result[0];\n    str = result[1];\n    symbol = AMgetSymbol(str);\n    if (symbol.ttype == INFIX && symbol.input == \"/\") {\n      str = AMremoveCharsAndBlanks(str,symbol.input.length);\n      result = AMparseIexpr(str);\n      if (result[0] == null) // show box in place of missing argument\n        result[0] = AMcreateMmlNode(\"mo\",document.createTextNode(\"\\u25A1\"));\n      else AMremoveBrackets(result[0]);\n      str = result[1];\n      AMremoveBrackets(node);\n      node = AMcreateMmlNode(symbol.tag,node);\n      node.appendChild(result[0]);\n      newFrag.appendChild(node);\n      symbol = AMgetSymbol(str);\n    } \n    else if (node!=undefined) newFrag.appendChild(node);\n  } while ((symbol.ttype != RIGHTBRACKET && \n           (symbol.ttype != LEFTRIGHT || rightbracket)\n           || AMnestingDepth == 0) && symbol!=null && symbol.output!=\"\");\n  if (symbol.ttype == RIGHTBRACKET || symbol.ttype == LEFTRIGHT) {\n//    if (AMnestingDepth > 0) AMnestingDepth--;\n    var len = newFrag.childNodes.length;\n    if (len>0 && newFrag.childNodes[len-1].nodeName == \"mrow\" && len>1 &&\n      newFrag.childNodes[len-2].nodeName == \"mo\" &&\n      newFrag.childNodes[len-2].firstChild.nodeValue == \",\") { //matrix\n      var right = newFrag.childNodes[len-1].lastChild.firstChild.nodeValue;\n      if (right==\")\" || right==\"]\") {\n        var left = newFrag.childNodes[len-1].firstChild.firstChild.nodeValue;\n        if (left==\"(\" && right==\")\" && symbol.output != \"}\" || \n            left==\"[\" && right==\"]\") {\n        var pos = []; // positions of commas\n        var matrix = true;\n        var m = newFrag.childNodes.length;\n        for (i=0; matrix && i<m; i=i+2) {\n          pos[i] = [];\n          node = newFrag.childNodes[i];\n          if (matrix) matrix = node.nodeName==\"mrow\" && \n            (i==m-1 || node.nextSibling.nodeName==\"mo\" && \n            node.nextSibling.firstChild.nodeValue==\",\")&&\n            node.firstChild.firstChild.nodeValue==left &&\n            node.lastChild.firstChild.nodeValue==right;\n          if (matrix) \n            for (var j=0; j<node.childNodes.length; j++)\n              if (node.childNodes[j].firstChild.nodeValue==\",\")\n                pos[i][pos[i].length]=j;\n          if (matrix && i>1) matrix = pos[i].length == pos[i-2].length;\n        }\n        if (matrix) {\n          var row, frag, n, k, table = document.createDocumentFragment();\n          for (i=0; i<m; i=i+2) {\n            row = document.createDocumentFragment();\n            frag = document.createDocumentFragment();\n            node = newFrag.firstChild; // <mrow>(-,-,...,-,-)</mrow>\n            n = node.childNodes.length;\n            k = 0;\n            node.removeChild(node.firstChild); //remove (\n            for (j=1; j<n-1; j++) {\n              if (typeof pos[i][k] != \"undefined\" && j==pos[i][k]){\n                node.removeChild(node.firstChild); //remove ,\n                row.appendChild(AMcreateMmlNode(\"mtd\",frag));\n                k++;\n              } else frag.appendChild(node.firstChild);\n            }\n            row.appendChild(AMcreateMmlNode(\"mtd\",frag));\n            if (newFrag.childNodes.length>2) {\n              newFrag.removeChild(newFrag.firstChild); //remove <mrow>)</mrow>\n              newFrag.removeChild(newFrag.firstChild); //remove <mo>,</mo>\n            }\n            table.appendChild(AMcreateMmlNode(\"mtr\",row));\n          }\n          node = AMcreateMmlNode(\"mtable\",table);\n          if (typeof symbol.invisible == \"boolean\" && symbol.invisible) node.setAttribute(\"columnalign\",\"left\");\n          newFrag.replaceChild(node,newFrag.firstChild);\n        }\n       }\n      }\n    }\n    str = AMremoveCharsAndBlanks(str,symbol.input.length);\n    if (typeof symbol.invisible != \"boolean\" || !symbol.invisible) {\n      node = AMcreateMmlNode(\"mo\",document.createTextNode(symbol.output));\n      newFrag.appendChild(node);\n    }\n  }\n  return [newFrag,str];\n}\n\nfunction AMparseMath(str) {\n  var result, node = AMcreateElementMathML(\"mstyle\");\n  if (mathcolor != \"\") node.setAttribute(\"mathcolor\",mathcolor);\n  if (displaystyle) node.setAttribute(\"displaystyle\",\"true\");\n  if (mathfontfamily != \"\") node.setAttribute(\"fontfamily\",mathfontfamily);\n  AMnestingDepth = 0;\n  node.appendChild(AMparseExpr(str.replace(/^\\s+/g,\"\"),false)[0]);\n  node = AMcreateMmlNode(\"math\",node);\n  if (showasciiformulaonhover)                      //fixed by djhsu so newline\n    node.setAttribute(\"title\",str.replace(/\\s+/g,\" \"));//does not show in Gecko\n  if (mathfontfamily != \"\" && (isIE || mathfontfamily != \"serif\")) {\n    var fnode = AMcreateElementXHTML(\"font\");\n    fnode.setAttribute(\"face\",mathfontfamily);\n    fnode.appendChild(node);\n    return fnode;\n  }\n  return node;\n}\n\nfunction AMstrarr2docFrag(arr, linebreaks) {\n  var newFrag=document.createDocumentFragment();\n  var expr = false;\n  for (var i=0; i<arr.length; i++) {\n    if (expr) newFrag.appendChild(AMparseMath(arr[i]));\n    else {\n      var arri = (linebreaks ? arr[i].split(\"\\n\\n\") : [arr[i]]);\n      newFrag.appendChild(AMcreateElementXHTML(\"span\").\n      appendChild(document.createTextNode(arri[0])));\n      for (var j=1; j<arri.length; j++) {\n        newFrag.appendChild(AMcreateElementXHTML(\"p\"));\n        newFrag.appendChild(AMcreateElementXHTML(\"span\").\n        appendChild(document.createTextNode(arri[j])));\n      }\n    }\n    expr = !expr;\n  }\n  return newFrag;\n}\n\nfunction AMprocessNodeR(n, linebreaks) {\n  var mtch, str, arr, frg, i;\n  if (n.childNodes.length == 0) {\n   if ((n.nodeType!=8 || linebreaks) &&\n    n.parentNode.nodeName!=\"form\" && n.parentNode.nodeName!=\"FORM\" &&\n    n.parentNode.nodeName!=\"textarea\" && n.parentNode.nodeName!=\"TEXTAREA\" &&\n    n.parentNode.nodeName!=\"code\" && n.parentNode.nodeName!=\"CODE\" &&  /* ASCIIMathML.js - copyright Peter Jipsen, released under the GPL\nSee http://www1.chapman.edu/~jipsen/mathml/asciimath.html/ */\n    n.parentNode.nodeName!=\"pre\" && n.parentNode.nodeName!=\"PRE\") {\n    str = n.nodeValue;\n    if (!(str == null)) {\n      str = str.replace(/\\r\\n\\r\\n/g,\"\\n\\n\");\n      if (doubleblankmathdelimiter) {\n        str = str.replace(/\\x20\\x20\\./g,\" \"+AMdelimiter1+\".\");\n        str = str.replace(/\\x20\\x20,/g,\" \"+AMdelimiter1+\",\");\n        str = str.replace(/\\x20\\x20/g,\" \"+AMdelimiter1+\" \");\n      }\n      str = str.replace(/\\x20+/g,\" \");\n      str = str.replace(/\\s*\\r\\n/g,\" \");\n      mtch = false;\n      str = str.replace(new RegExp(AMescape2, \"g\"),\n              function(st){mtch=true;return \"AMescape2\"});\n      str = str.replace(new RegExp(AMescape1, \"g\"),\n              function(st){mtch=true;return \"AMescape1\"});\n      str = str.replace(new RegExp(AMdelimiter2regexp, \"g\"),AMdelimiter1);\n      arr = str.split(AMdelimiter1);\n      for (i=0; i<arr.length; i++)\n        arr[i]=arr[i].replace(/AMescape2/g,AMdelimiter2).\n                      replace(/AMescape1/g,AMdelimiter1);\n      if (arr.length>1 || mtch) {\n        if (checkForMathML) {\n          checkForMathML = false;\n          var nd = AMisMathMLavailable();\n          AMnoMathML = nd != null;\n          if (AMnoMathML && notifyIfNoMathML) \n            if (alertIfNoMathML)\n              alert(\"To view the ASCIIMathML notation use Internet Explorer 6 +\\nMathPlayer (free from www.dessci.com)\\n\\\n                or Firefox/Mozilla/Netscape\");\n            else AMbody.insertBefore(nd,AMbody.childNodes[0]);\n        }\n        if (!AMnoMathML) {\n          frg = AMstrarr2docFrag(arr,n.nodeType==8);\n          var len = frg.childNodes.length;\n          n.parentNode.replaceChild(frg,n);\n          return len-1;\n        } else return 0;\n      }\n    }\n   } else return 0;\n  } else if (n.nodeName!=\"math\") {\n    for (i=0; i<n.childNodes.length; i++)\n      i += AMprocessNodeR(n.childNodes[i], linebreaks);\n  }\n  return 0;\n}\n\nfunction AMprocessNode(n, linebreaks, spanclassAM) {\n  var frag,st;\n  if (spanclassAM!=null) {\n    frag = document.getElementsByTagName(\"span\")\n    for (var i=0;i<frag.length;i++)\n      if (frag[i].className == \"AM\")\n        AMprocessNodeR(frag[i],linebreaks);\n  } else {\n    try {\n      st = n.innerHTML;\n    } catch(err) {}\n    if (st==null || \n        st.indexOf(AMdelimiter1)!=-1 || st.indexOf(AMdelimiter2)!=-1) \n      AMprocessNodeR(n,linebreaks);\n  }\n  if (isIE) { //needed to match size and font of formula to surrounding text\n    frag = document.getElementsByTagName('math');\n    for (var i=0;i<frag.length;i++) frag[i].update()\n  }\n}\n\nvar AMbody;\nvar AMnoMathML = false, AMtranslated = false;\n\nfunction translate(spanclassAM) {\n  if (!AMtranslated) { // run this only once\n    AMtranslated = true;\n    AMinitSymbols();\n    AMbody = document.getElementsByTagName(\"body\")[0];\n    AMprocessNode(AMbody, false, spanclassAM);\n  }\n}\n\nif (isIE) { // avoid adding MathPlayer info explicitly to each webpage\n  document.write(\"<object id=\\\"mathplayer\\\"\\\n  classid=\\\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\\\"></object>\");\n  document.write(\"<?import namespace=\\\"m\\\" implementation=\\\"#mathplayer\\\"?>\");\n}\n\n// GO1.1 Generic onload by Brothercake \n// http://www.brothercake.com/\n//onload function (replaces the onload=\"translate()\" in the <body> tag)\nfunction generic()\n{\n  translate();\n};\n//setup onload function\nif(typeof window.addEventListener != 'undefined')\n{\n  //.. gecko, safari, konqueror and standard\n  window.addEventListener('load', generic, false);\n}\nelse if(typeof document.addEventListener != 'undefined')\n{\n  //.. opera 7\n  document.addEventListener('load', generic, false);\n}\nelse if(typeof window.attachEvent != 'undefined')\n{\n  //.. win/ie\n  window.attachEvent('onload', generic);\n}\n//** remove this condition to degrade older browsers\nelse\n{\n  //.. mac/ie5 and anything else that gets this far\n  //if there's an existing onload function\n  if(typeof window.onload == 'function')\n  {\n    //store it\n    var existing = onload;\n    //add new onload handler\n    window.onload = function()\n    {\n      //call existing onload function\n      existing();\n      //call generic onload function\n      generic();\n    };\n  }\n  else\n  {\n    //setup onload function\n    window.onload = generic;\n  }\n}\n</script>\n"

